// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gin-admin-api/model"
)

func newTest1Entity(db *gorm.DB, opts ...gen.DOOption) test1Entity {
	_test1Entity := test1Entity{}

	_test1Entity.test1EntityDo.UseDB(db, opts...)
	_test1Entity.test1EntityDo.UseModel(&model.Test1Entity{})

	tableName := _test1Entity.test1EntityDo.TableName()
	_test1Entity.ALL = field.NewAsterisk(tableName)
	_test1Entity.ID = field.NewInt64(tableName, "id")
	_test1Entity.Username = field.NewString(tableName, "username")
	_test1Entity.Version = field.NewField(tableName, "version")

	_test1Entity.fillFieldMap()

	return _test1Entity
}

type test1Entity struct {
	test1EntityDo

	ALL      field.Asterisk
	ID       field.Int64
	Username field.String
	Version  field.Field

	fieldMap map[string]field.Expr
}

func (t test1Entity) Table(newTableName string) *test1Entity {
	t.test1EntityDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t test1Entity) As(alias string) *test1Entity {
	t.test1EntityDo.DO = *(t.test1EntityDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *test1Entity) updateTableName(table string) *test1Entity {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.Username = field.NewString(table, "username")
	t.Version = field.NewField(table, "version")

	t.fillFieldMap()

	return t
}

func (t *test1Entity) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *test1Entity) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 3)
	t.fieldMap["id"] = t.ID
	t.fieldMap["username"] = t.Username
	t.fieldMap["version"] = t.Version
}

func (t test1Entity) clone(db *gorm.DB) test1Entity {
	t.test1EntityDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t test1Entity) replaceDB(db *gorm.DB) test1Entity {
	t.test1EntityDo.ReplaceDB(db)
	return t
}

type test1EntityDo struct{ gen.DO }

type ITest1EntityDo interface {
	gen.SubQuery
	Debug() ITest1EntityDo
	WithContext(ctx context.Context) ITest1EntityDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITest1EntityDo
	WriteDB() ITest1EntityDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITest1EntityDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITest1EntityDo
	Not(conds ...gen.Condition) ITest1EntityDo
	Or(conds ...gen.Condition) ITest1EntityDo
	Select(conds ...field.Expr) ITest1EntityDo
	Where(conds ...gen.Condition) ITest1EntityDo
	Order(conds ...field.Expr) ITest1EntityDo
	Distinct(cols ...field.Expr) ITest1EntityDo
	Omit(cols ...field.Expr) ITest1EntityDo
	Join(table schema.Tabler, on ...field.Expr) ITest1EntityDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITest1EntityDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITest1EntityDo
	Group(cols ...field.Expr) ITest1EntityDo
	Having(conds ...gen.Condition) ITest1EntityDo
	Limit(limit int) ITest1EntityDo
	Offset(offset int) ITest1EntityDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITest1EntityDo
	Unscoped() ITest1EntityDo
	Create(values ...*model.Test1Entity) error
	CreateInBatches(values []*model.Test1Entity, batchSize int) error
	Save(values ...*model.Test1Entity) error
	First() (*model.Test1Entity, error)
	Take() (*model.Test1Entity, error)
	Last() (*model.Test1Entity, error)
	Find() ([]*model.Test1Entity, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Test1Entity, err error)
	FindInBatches(result *[]*model.Test1Entity, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Test1Entity) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITest1EntityDo
	Assign(attrs ...field.AssignExpr) ITest1EntityDo
	Joins(fields ...field.RelationField) ITest1EntityDo
	Preload(fields ...field.RelationField) ITest1EntityDo
	FirstOrInit() (*model.Test1Entity, error)
	FirstOrCreate() (*model.Test1Entity, error)
	FindByPage(offset int, limit int) (result []*model.Test1Entity, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITest1EntityDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t test1EntityDo) Debug() ITest1EntityDo {
	return t.withDO(t.DO.Debug())
}

func (t test1EntityDo) WithContext(ctx context.Context) ITest1EntityDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t test1EntityDo) ReadDB() ITest1EntityDo {
	return t.Clauses(dbresolver.Read)
}

func (t test1EntityDo) WriteDB() ITest1EntityDo {
	return t.Clauses(dbresolver.Write)
}

func (t test1EntityDo) Session(config *gorm.Session) ITest1EntityDo {
	return t.withDO(t.DO.Session(config))
}

func (t test1EntityDo) Clauses(conds ...clause.Expression) ITest1EntityDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t test1EntityDo) Returning(value interface{}, columns ...string) ITest1EntityDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t test1EntityDo) Not(conds ...gen.Condition) ITest1EntityDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t test1EntityDo) Or(conds ...gen.Condition) ITest1EntityDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t test1EntityDo) Select(conds ...field.Expr) ITest1EntityDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t test1EntityDo) Where(conds ...gen.Condition) ITest1EntityDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t test1EntityDo) Order(conds ...field.Expr) ITest1EntityDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t test1EntityDo) Distinct(cols ...field.Expr) ITest1EntityDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t test1EntityDo) Omit(cols ...field.Expr) ITest1EntityDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t test1EntityDo) Join(table schema.Tabler, on ...field.Expr) ITest1EntityDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t test1EntityDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITest1EntityDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t test1EntityDo) RightJoin(table schema.Tabler, on ...field.Expr) ITest1EntityDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t test1EntityDo) Group(cols ...field.Expr) ITest1EntityDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t test1EntityDo) Having(conds ...gen.Condition) ITest1EntityDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t test1EntityDo) Limit(limit int) ITest1EntityDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t test1EntityDo) Offset(offset int) ITest1EntityDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t test1EntityDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITest1EntityDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t test1EntityDo) Unscoped() ITest1EntityDo {
	return t.withDO(t.DO.Unscoped())
}

func (t test1EntityDo) Create(values ...*model.Test1Entity) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t test1EntityDo) CreateInBatches(values []*model.Test1Entity, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t test1EntityDo) Save(values ...*model.Test1Entity) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t test1EntityDo) First() (*model.Test1Entity, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Test1Entity), nil
	}
}

func (t test1EntityDo) Take() (*model.Test1Entity, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Test1Entity), nil
	}
}

func (t test1EntityDo) Last() (*model.Test1Entity, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Test1Entity), nil
	}
}

func (t test1EntityDo) Find() ([]*model.Test1Entity, error) {
	result, err := t.DO.Find()
	return result.([]*model.Test1Entity), err
}

func (t test1EntityDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Test1Entity, err error) {
	buf := make([]*model.Test1Entity, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t test1EntityDo) FindInBatches(result *[]*model.Test1Entity, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t test1EntityDo) Attrs(attrs ...field.AssignExpr) ITest1EntityDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t test1EntityDo) Assign(attrs ...field.AssignExpr) ITest1EntityDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t test1EntityDo) Joins(fields ...field.RelationField) ITest1EntityDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t test1EntityDo) Preload(fields ...field.RelationField) ITest1EntityDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t test1EntityDo) FirstOrInit() (*model.Test1Entity, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Test1Entity), nil
	}
}

func (t test1EntityDo) FirstOrCreate() (*model.Test1Entity, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Test1Entity), nil
	}
}

func (t test1EntityDo) FindByPage(offset int, limit int) (result []*model.Test1Entity, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t test1EntityDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t test1EntityDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t test1EntityDo) Delete(models ...*model.Test1Entity) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *test1EntityDo) withDO(do gen.Dao) *test1EntityDo {
	t.DO = *do.(*gen.DO)
	return t
}
